// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package queries

import (
	"context"
)

const findAccountByID = `-- name: FindAccountByID :one
SELECT ac.id, ac.account_type, ac.customer_name, ac.document_number, ac.email, ac.password_encoded, ac.salt_hash_password, ac.phone_number, ac.status, ac.created_at, ac.updated_at, json_group_array(json_object('id', tr.id, 'amount', tr.amount, 'account_id', tr.account_id, 'correlated_id', tr.correlated_id, 'timestamp', tr."timestamp", 'transaction_type', tr.transaction_type)) as transactions
FROM accounts ac
LEFT JOIN transactions tr ON ac.id = tr.account_id
WHERE ac.id = ? GROUP BY ac.id
`

type FindAccountByIDRow struct {
	Account      Account     `db:"account" json:"account"`
	Transactions interface{} `db:"transactions" json:"transactions"`
}

func (q *Queries) FindAccountByID(ctx context.Context, id interface{}) (FindAccountByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findAccountByID, id)
	var i FindAccountByIDRow
	err := row.Scan(
		&i.Account.ID,
		&i.Account.AccountType,
		&i.Account.CustomerName,
		&i.Account.DocumentNumber,
		&i.Account.Email,
		&i.Account.PasswordEncoded,
		&i.Account.SaltHashPassword,
		&i.Account.PhoneNumber,
		&i.Account.Status,
		&i.Account.CreatedAt,
		&i.Account.UpdatedAt,
		&i.Transactions,
	)
	return i, err
}

const insertNewAccount = `-- name: InsertNewAccount :exec
INSERT INTO accounts (id,account_type,customer_name,document_number,email,password_encoded,salt_hash_password,phone_number,status,created_at,updated_at) 
VALUES (?,?,?,?,?,?,?,?,?,?,?)
`

type InsertNewAccountParams struct {
	ID               interface{} `db:"id" json:"id"`
	AccountType      string      `db:"account_type" json:"account_type"`
	CustomerName     string      `db:"customer_name" json:"customer_name"`
	DocumentNumber   string      `db:"document_number" json:"document_number"`
	Email            string      `db:"email" json:"email"`
	PasswordEncoded  string      `db:"password_encoded" json:"password_encoded"`
	SaltHashPassword string      `db:"salt_hash_password" json:"salt_hash_password"`
	PhoneNumber      string      `db:"phone_number" json:"phone_number"`
	Status           string      `db:"status" json:"status"`
	CreatedAt        interface{} `db:"created_at" json:"created_at"`
	UpdatedAt        interface{} `db:"updated_at" json:"updated_at"`
}

func (q *Queries) InsertNewAccount(ctx context.Context, arg InsertNewAccountParams) error {
	_, err := q.db.ExecContext(ctx, insertNewAccount,
		arg.ID,
		arg.AccountType,
		arg.CustomerName,
		arg.DocumentNumber,
		arg.Email,
		arg.PasswordEncoded,
		arg.SaltHashPassword,
		arg.PhoneNumber,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertNewTransaction = `-- name: InsertNewTransaction :exec
INSERT INTO transactions (id,correlated_id,account_id,transaction_type,timestamp,amount)
VALUES (?,?,?,?,?,?)
`

type InsertNewTransactionParams struct {
	ID              interface{} `db:"id" json:"id"`
	CorrelatedID    interface{} `db:"correlated_id" json:"correlated_id"`
	AccountID       interface{} `db:"account_id" json:"account_id"`
	TransactionType string      `db:"transaction_type" json:"transaction_type"`
	Timestamp       interface{} `db:"timestamp" json:"timestamp"`
	Amount          int64       `db:"amount" json:"amount"`
}

func (q *Queries) InsertNewTransaction(ctx context.Context, arg InsertNewTransactionParams) error {
	_, err := q.db.ExecContext(ctx, insertNewTransaction,
		arg.ID,
		arg.CorrelatedID,
		arg.AccountID,
		arg.TransactionType,
		arg.Timestamp,
		arg.Amount,
	)
	return err
}
